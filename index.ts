import "@jxa/global-type"
import { run } from "@jxa/run"
import { readFileSync } from "fs"
import { join } from "path"

/**
 * ClientWindow represents the Chrome windows spawned by this script.
 * The id is generated by MacOS.
 * x and y are the left and top positions relative to the entire screen
 */
type ClientWindow = {
  id: number
  x: number
  y: number
  width: number
  height: number
}

/**
 * ghostWidth and ghostHeight are static. This is the size of the PNG.
 */

const ghostWidth = 266
const ghostHeight = 240

/**
 * These global values are the current state. They can be updated at any time.
 */

let clientWindows: Array<ClientWindow> = []
let screenWidth = 0
let screenHeight = 0
let ghostX = 0
let ghostY = 0
let ghostGoalX = 0
let ghostGoalY = 0

/**
 * fetchWindowPositions looks for all Chrome windows and puts them in the global client windows
 * This is called regularly, so the user can move Chrome windows around.
 */
async function fetchWindowPositions() {
  const res: Array<ClientWindow> = await run(() => {
    // This is JXA code. It is turned into a string.
    // It cannot access the surrounding memory space.
    // JXA is weird.
    return Application("Google Chrome")
      .windows()
      .map((win: any): ClientWindow => {
        const bounds = win.bounds()
        return {
          id: win.id(),
          x: bounds.x,
          y: bounds.y,
          width: bounds.width,
          height: bounds.height,
        }
      })
  })

  clientWindows.length = 0

  res.forEach((v) => clientWindows.push(v))
}

function positionGhost() {
  const atX = ghostX === ghostGoalX
  const atY = ghostY === ghostGoalY
  if (atX && atY) {
    let newX = Math.max(0, Math.floor(Math.random() * screenWidth - ghostWidth))
    let newY = Math.max(
      0,
      Math.floor(Math.random() * screenHeight - ghostHeight)
    )
    newX = newX - (newX % 10)
    newY = newY - (newY % 10)
    ghostGoalX = newX
    ghostGoalY = newY
    return
  }

  if (!atX) {
    ghostX = ghostX > ghostGoalX ? ghostX - 10 : ghostX + 10
  }
  if (!atY) {
    ghostY = ghostY > ghostGoalY ? ghostY - 10 : ghostY + 10
  }
}

async function setupBrowserWindows() {
  const res: Array<number> = await run(() => {
    // This is JXA code. It is turned into a string.
    // It cannot access the surrounding memory space.
    // JXA is weird.

    // Objective C bridge
    ObjC.import("AppKit")

    const CLIENT_WINDOW_COUNT = 3
    const GAP = 50

    const mainScreen = $.NSScreen.mainScreen
    const screenFrame = mainScreen.frame
    const screenWidth = screenFrame.size.width
    const screenHeight = screenFrame.size.height

    const windowWidth =
      (screenWidth - (GAP * CLIENT_WINDOW_COUNT - 1)) / CLIENT_WINDOW_COUNT
    const windowHeight = screenHeight / 2

    const chrome = Application("Google Chrome")
    for (let i = 0; i < CLIENT_WINDOW_COUNT; i++) {
      const win = chrome.Window().make()
      win.activeTab.url = "http://localhost:3000/" + win.id()
      const x = i * windowWidth + i * GAP
      win.bounds = {
        x: x,
        y: windowHeight / 2,
        width: windowWidth,
        height: windowHeight,
      }
    }

    return [screenWidth, screenHeight]
  })

  screenWidth = res[0]
  screenHeight = res[1]
}

// Set up the SIGINT listener
process.on("SIGINT", async () => {
  await run(() => {
    Application("Google Chrome")
      .windows()
      .forEach((win: any) => {
        win.close()
      })
  })

  process.exit(0)
})

setupBrowserWindows()
setInterval(fetchWindowPositions, 100)
setInterval(positionGhost, 50)

// This is the webserver.
// It handles serving the client app, the ghost image, and client requests to know
// where that ghost is.
Bun.serve({
  port: 3000,
  fetch(req) {
    const url = new URL(req.url)

    // handle the image
    if (url.pathname === "/ghost.png") {
      const filePath = join(process.cwd(), "ghost.png")
      const fileContents = readFileSync(filePath)
      return new Response(fileContents, {
        headers: {
          "Content-Type": "image/png",
        },
      })
    }

    const isGhostFinderRequest = req.headers.has("x-ghost-finder")
    if (!isGhostFinderRequest) {
      const clientApp = `
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Ghost in the Mac</title>
    </head>
    <body style="background: black;">
        <img id="ghost" style="position:absolute; top:-500; left:-500;" src="/ghost.png" />
        <script>
            setInterval(async function () {
              const response = await fetch(window.location.pathname, {
                method: "GET",
                headers: {
                  Accept: "application/json",
                  "x-ghost-finder": "your-custom-header-value",
                },
              })
             
              const data = await response.json()
              const ghostImage =document.getElementById('ghost')
              ghostImage.style.left = data.ghostX + 'px';
              ghostImage.style.top = data.ghostY + 'px';
            }, 50)
              
        </script>
    </body>
</html>
`
      return new Response(clientApp, {
        headers: {
          "Content-Type": "text/html",
        },
      })
    }

    const windowId = parseInt(url.pathname.split("/")[1])
    if (isNaN(windowId)) {
      return new Response(null, { status: 404 })
    }

    const window = clientWindows.find((win) => win.id == windowId)

    // handle the window not being ready, or some invalid id somehow
    if (!window) {
      return new Response(null, { status: 202 })
    }

    // If window is found, serve content based on id
    if (window) {
      const clientGhostX = ghostX - window.x
      const clientGhostY = ghostY - window.y
      const jsonResponse = JSON.stringify({
        ghostX: clientGhostX,
        ghostY: clientGhostY,
      })

      return new Response(jsonResponse, {
        headers: {
          "Content-Type": "application/json",
        },
      })
    }

    return new Response(null, { status: 404 })
  },
})
